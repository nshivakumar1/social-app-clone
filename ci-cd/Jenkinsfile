pipeline {
    agent any
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '297997106614'
        ECR_REPOSITORY = 'social-app-clone'
        ECS_CLUSTER = 'social-app-clone'
        ECS_SERVICE = 'social-app-clone'
        IMAGE_TAG = "${env.BUILD_NUMBER}"
        GIT_REPO = 'https://github.com/YOUR_USERNAME/social-app-clone.git'
        SLACK_CHANNEL = '#social-clone-app'
        JIRA_PROJECT_KEY = 'SAC'
        JIRA_HOST = 'learndevopswithkodekloud.atlassian.net'
    }
    
    stages {
        stage('üîç Checkout') {
            steps {
                script {
                    echo "üì• Checking out code from GitHub..."
                    checkout scm
                    
                    // Get commit info
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_COMMIT_MSG = sh(
                        script: "git log -1 --pretty=format:'%s'",
                        returnStdout: true
                    ).trim()
                    
                    echo "üìù Commit: ${env.GIT_COMMIT_SHORT} - ${env.GIT_COMMIT_MSG}"
                }
            }
        }
        
        stage('üß™ Test') {
            steps {
                script {
                    try {
                        echo "üß™ Running tests..."
                        sh '''
                            cd app
                            # Add your test commands here
                            # npm test || echo "No tests defined yet"
                            echo "‚úÖ Tests passed (placeholder)"
                        '''
                    } catch (Exception e) {
                        sendSlackNotification("‚ùå Tests failed for commit ${env.GIT_COMMIT_SHORT}", "danger")
                        createJiraIncident("Tests failed: ${e.getMessage()}")
                        throw e
                    }
                }
            }
        }
        
        stage('üêã Build Docker Image') {
            steps {
                script {
                    try {
                        echo "üî® Building Docker image..."
                        sh '''
                            cd app
                            docker build --platform linux/amd64 -t ${ECR_REPOSITORY}:${IMAGE_TAG} .
                            docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REPOSITORY}:latest
                            docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REPOSITORY}:${GIT_COMMIT_SHORT}
                        '''
                        echo "‚úÖ Docker image built successfully"
                    } catch (Exception e) {
                        sendSlackNotification("‚ùå Docker build failed for commit ${env.GIT_COMMIT_SHORT}", "danger")
                        createJiraIncident("Docker build failed: ${e.getMessage()}")
                        throw e
                    }
                }
            }
        }
        
        stage('üì§ Push to ECR') {
            steps {
                script {
                    try {
                        withCredentials([
                            string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                            string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                        ]) {
                            sh '''
                                # Configure AWS CLI
                                aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                                aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                                aws configure set default.region $AWS_DEFAULT_REGION
                                
                                # Login to ECR
                                aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
                                
                                # Tag and push images
                                docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}
                                docker tag ${ECR_REPOSITORY}:latest ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:latest
                                docker tag ${ECR_REPOSITORY}:${GIT_COMMIT_SHORT} ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:${GIT_COMMIT_SHORT}
                                
                                docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}
                                docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:latest
                                docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPOSITORY}:${GIT_COMMIT_SHORT}
                            '''
                        }
                        sendSlackNotification("‚úÖ Image pushed to ECR: ${IMAGE_TAG} (${env.GIT_COMMIT_SHORT})", "good")
                    } catch (Exception e) {
                        sendSlackNotification("‚ùå ECR push failed for ${env.GIT_COMMIT_SHORT}", "danger")
                        createJiraIncident("ECR push failed: ${e.getMessage()}")
                        throw e
                    }
                }
            }
        }
        
        stage('üöÄ Deploy to ECS') {
            steps {
                script {
                    try {
                        withCredentials([
                            string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                            string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                        ]) {
                            sh '''
                                echo "üöÄ Deploying to ECS Fargate..."
                                aws ecs update-service \
                                    --cluster ${ECS_CLUSTER} \
                                    --service ${ECS_SERVICE} \
                                    --force-new-deployment \
                                    --region ${AWS_DEFAULT_REGION}
                                
                                echo "‚è≥ Waiting for ECS deployment to stabilize..."
                                aws ecs wait services-stable \
                                    --cluster ${ECS_CLUSTER} \
                                    --services ${ECS_SERVICE} \
                                    --region ${AWS_DEFAULT_REGION}
                            '''
                        }
                        sendSlackNotification("üöÄ ECS deployment completed for build ${IMAGE_TAG}", "good")
                    } catch (Exception e) {
                        sendSlackNotification("‚ùå ECS deployment failed for ${env.GIT_COMMIT_SHORT}", "danger")
                        createJiraIncident("ECS deployment failed: ${e.getMessage()}")
                        throw e
                    }
                }
            }
        }
        
        stage('üìù Update GitOps Manifests') {
            steps {
                script {
                    try {
                        withCredentials([string(credentialsId: 'github-token', variable: 'GITHUB_TOKEN')]) {
                            sh '''
                                echo "üìù Updating Kubernetes manifests for GitOps..."
                                
                                # Configure git
                                git config user.email "jenkins@company.com"
                                git config user.name "Jenkins CI/CD"
                                
                                # Update image tag in kustomization
                                sed -i "s|newTag: .*|newTag: ${IMAGE_TAG}|g" k8s-manifests/base/kustomization.yaml
                                sed -i "s|newTag: .*|newTag: ${IMAGE_TAG}|g" k8s-manifests/overlays/production/kustomization.yaml
                                
                                # Create commit with build info
                                git add k8s-manifests/
                                git commit -m "üöÄ Deploy ${IMAGE_TAG} - ${GIT_COMMIT_MSG} [skip ci]" || echo "No changes to commit"
                                
                                # Push using token
                                git remote set-url origin https://${GITHUB_TOKEN}@github.com/YOUR_USERNAME/social-app-clone.git
                                git push origin main
                            '''
                        }
                        sendSlackNotification("üìù GitOps manifests updated with image ${IMAGE_TAG}", "good")
                    } catch (Exception e) {
                        sendSlackNotification("‚ùå GitOps update failed", "warning")
                        createJiraIncident("GitOps manifest update failed: ${e.getMessage()}")
                        // Don't fail the pipeline for GitOps issues
                        echo "‚ö†Ô∏è GitOps update failed, but continuing..."
                    }
                }
            }
        }
        
        stage('üîÑ Trigger ArgoCD Sync') {
            steps {
                script {
                    try {
                        sh '''
                            echo "üîÑ Triggering ArgoCD sync..."
                            
                            # Check if kubectl is configured (optional step)
                            if kubectl version --client >/dev/null 2>&1; then
                                # Patch ArgoCD app to refresh
                                kubectl patch app social-app-clone -n argocd -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"'"$(date)"'"}}}' --type merge 2>/dev/null || echo "ArgoCD app not found, will be created manually"
                            else
                                echo "kubectl not configured, ArgoCD will auto-sync"
                            fi
                        '''
                        sendSlackNotification("üîÑ ArgoCD sync triggered for Kubernetes deployment", "good")
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è ArgoCD sync trigger failed, but ArgoCD will auto-sync"
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up docker images
                sh '''
                    docker rmi ${ECR_REPOSITORY}:${IMAGE_TAG} || true
                    docker rmi ${ECR_REPOSITORY}:latest || true
                    docker rmi ${ECR_REPOSITORY}:${GIT_COMMIT_SHORT} || true
                '''
            }
            cleanWs()
        }
        success {
            sendSlackNotification("‚úÖ Complete CI/CD pipeline successful! üéâ\\nBuild: ${env.BUILD_NUMBER}\\nCommit: ${env.GIT_COMMIT_SHORT}\\nMessage: ${env.GIT_COMMIT_MSG}", "good")
        }
        failure {
            sendSlackNotification("‚ùå Pipeline failed! üí•\\nBuild: ${env.BUILD_NUMBER}\\nCommit: ${env.GIT_COMMIT_SHORT}\\nCheck: ${env.BUILD_URL}", "danger")
        }
    }
}

// Helper functions
def sendSlackNotification(String message, String color = 'good') {
    script {
        try {
            sh """
                export SLACK_WEBHOOK_URL=\$(aws ssm get-parameter --name /social-app/slack/webhook-url --with-decryption --query 'Parameter.Value' --output text 2>/dev/null || echo 'not-configured')
                if [ "\$SLACK_WEBHOOK_URL" != "not-configured" ]; then
                    export SLACK_CHANNEL=${SLACK_CHANNEL}
                    node integrations/slack-notification.js "${message}" "${color}"
                fi
            """
        } catch (Exception e) {
            echo "‚ö†Ô∏è Slack notification failed: ${e.getMessage()}"
        }
    }
}

def createJiraIncident(String description) {
    script {
        try {
            sh """
                export JIRA_HOST=${JIRA_HOST}
                export JIRA_USERNAME=\$(aws ssm get-parameter --name /social-app/jira/username --query 'Parameter.Value' --output text 2>/dev/null || echo 'not-configured')
                export JIRA_API_TOKEN=\$(aws ssm get-parameter --name /social-app/jira/api-token --with-decryption --query 'Parameter.Value' --output text 2>/dev/null || echo 'not-configured')
                export JIRA_PROJECT_KEY=${JIRA_PROJECT_KEY}
                if [ "\$JIRA_USERNAME" != "not-configured" ]; then
                    node integrations/jira-webhook.js "${description}"
                fi
            """
        } catch (Exception e) {
            echo "‚ö†Ô∏è Jira incident creation failed: ${e.getMessage()}"
        }
    }
}